第一种考虑
======================

+ 1.当容器为1的时候直接返回原容器元素

+ 2.对给定的容器进行排序

+ 3.从头遍历到有序容器进行异或操作

+ 4.当异或结果为0时（两个相等）count加1，否则count重新变为1

+ 5.当count大于n/2时返回当前遍历值。


> 时间复杂度为O(n),空间复杂度为O(1)



第二种考虑
==========================================

+ 1.从nums[1]开始遍历,保存nums[0]放在temp中，同时count为1

+ 2. 当nums[i]与temp相等时count加1，否则减1

+ 3.当count为0时，将nums[i+1]存在temp中，count变为1

+ 当遍历结束时，返回temp存放的数字就是出现最多次的数字

> 时间复杂度为O(n),空间复杂度为O(1)

