第一种分析：
=======================
在考虑本题的过程中个人比较倾向使用从前往后遍历数组，类似于冒泡排序，将0看做冒泡排序过程中的最大值来处理，
但是在是实现过程中遇到的是当两个0相遇时或者0在移动到末尾的过程时交换都是很浪费操作时间的。在时间复杂度上面不占优势


第二种分析：
================================
1.发现第一种分析不占优势，换一种思路
2.利用2个指针，第一个指针指向从后往前的第一个非零元素。
3.第二个指针开始从第一个指针的下一个位置开始往前遍历，遇到0的时候停下，将
第一个指针所指的元素到第二个指针之间的元素整体向前移动一个位置，第一个指针
处变为0，然后第一个指针向前移动一位。
4.第二个指针继续从刚才指向0的位置向前遍历，遇到0重复操作3，到达a[0]并且
a[0]不等于0的情况下结束操作
> 在实现第二种分析的过程种发现复杂度也很大为O(n^3)，排除这种做法

第三种分析
=========================================
1.在看完discuss里面时候发现有一种更为简便并且时间复杂度为O(n)的压缩算法。
2.利用2个指针从前遍历到最后，第一个指针从前遍历到最后，第二个指针先为0
3.第一个指针向后面遍历遇到非0的元素的时候将此非零的元素赋给第二个指针所指的位置，
然后第二个指针同时加1指针下一个位置
4.第一个指针继续向后遍历，直到第一个指针指向最后一个元素的后面，然后从第二个
指针开始到最后的位置都变为0.
> 第三种时间复杂度为n
